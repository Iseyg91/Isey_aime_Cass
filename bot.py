import discord
from discord.ext import commands, tasks
from discord import app_commands, Embed, ButtonStyle, ui
from discord.ui import Button, View, Select, Modal, TextInput, button
from discord.ui import Modal, TextInput, Button, View
from discord.utils import get
from discord import TextStyle
from functools import wraps
import os
from discord import app_commands, Interaction, TextChannel, Role
import io
import random
import asyncio
import time
import re
import subprocess
import sys
import math
import traceback
from keep_alive import keep_alive
from datetime import datetime, timedelta
from collections import defaultdict, deque
import pymongo
from pymongo import MongoClient
from motor.motor_asyncio import AsyncIOMotorClient
import psutil
import pytz
import platform
from discord.ui import Select, View

token = os.environ['ETHERYA']
intents = discord.Intents.all()
start_time = time.time()
bot = commands.Bot(command_prefix="!!", intents=intents, help_command=None)

# Connexion MongoDB
mongo_uri = os.getenv("MONGO_DB")  # URI de connexion √† MongoDB
print("Mongo URI :", mongo_uri)  # Cela affichera l'URI de connexion (assure-toi de ne pas laisser cela en prod)
client = MongoClient(mongo_uri)
db = client['Cass-Eco2']

# Collections
collection = db['ether_eco']  #Stock les Bal
collection2 = db['ether_daily']  #Stock les cd de daily
collection3 = db['ether_slut']  #Stock les cd de slut
collection4 = db['ether_crime']  #Stock les cd de slut
collection5 = db['ether_collect'] #Stock les cd de collect
collection6 = db['ether_work'] #Stock les cd de Work
collection7 = db['ether_inventory'] #Stock les inventaires

def load_guild_settings(guild_id):
    # Charger les donn√©es de la collection principale
    ether_eco_data = collection.find_one({"guild_id": guild_id}) or {}
    ether_daily_data = collection2.find_one({"guild_id": guild_id}) or {}
    ether_slut_data = collection3.find_one({"guild_id": guild_id}) or {}
    ether_crime_data = collection4.find_one({"guild_id": guild_id}) or {}
    ether_collect = collection5.find_one({"guild_id": guild_id}) or {}
    ether_work_data = collection6.find_one({"guild_id": guild_id}) or {}
    ether_inventory_data = collection7.find_one({"guild_id": guild_id}) or {}

    # D√©bogage : Afficher les donn√©es de setup
    print(f"Setup data for guild {guild_id}: {setup_data}")

    combined_data = {
        "ether_eco": ether_eco_data,
        "ether_daily": ether_daily_data,
        "ether_slut": ether_slut_data,
        "ether_crime": ether_crime_data,
        "ether_collect": ether_collect_data,
        "ether_work": ether_work_data,
        "ether_inventory": ether_inventory_data

    }

    return combined_data

@bot.event
async def on_ready():
    print(f"‚úÖ Le bot {bot.user} est maintenant connect√© ! (ID: {bot.user.id})")

    # Initialisation de l'uptime du bot
    bot.uptime = time.time()
    
    # R√©cup√©ration du nombre de serveurs et d'utilisateurs
    guild_count = len(bot.guilds)
    member_count = sum(guild.member_count for guild in bot.guilds)
    
    # Affichage des statistiques du bot dans la console
    print(f"\nüìä **Statistiques du bot :**")
    print(f"‚û°Ô∏è **Serveurs** : {guild_count}")
    print(f"‚û°Ô∏è **Utilisateurs** : {member_count}")
    
    # Liste des activit√©s dynamiques
    activity_types = [
        discord.Activity(type=discord.ActivityType.watching, name=f"{member_count} Membres"),
        discord.Activity(type=discord.ActivityType.streaming, name=f"{guild_count} Serveurs"),
        discord.Activity(type=discord.ActivityType.streaming, name="Etherya"),
    ]
    
    # S√©lection d'une activit√© au hasard
    activity = random.choice(activity_types)
    
    # Choix d'un statut al√©atoire
    status_types = [discord.Status.online, discord.Status.idle, discord.Status.dnd]
    status = random.choice(status_types)
    
    # Mise √† jour du statut et de l'activit√©
    await bot.change_presence(activity=activity, status=status)
    
    print(f"\nüéâ **{bot.user}** est maintenant connect√© et affiche ses statistiques dynamiques avec succ√®s !")

    # Afficher les commandes charg√©es
    print("üìå Commandes disponibles üòä")
    for command in bot.commands:
        print(f"- {command.name}")

    try:
        # Synchroniser les commandes avec Discord
        synced = await bot.tree.sync()  # Synchronisation des commandes slash
        print(f"‚úÖ Commandes slash synchronis√©es : {[cmd.name for cmd in synced]}")
    except Exception as e:
        print(f"‚ùå Erreur de synchronisation des commandes slash : {e}")

    # Jongler entre diff√©rentes activit√©s et statuts
    while True:
        for activity in activity_types:
            for status in status_types:
                await bot.change_presence(status=status, activity=activity)
                await asyncio.sleep(10)  # Attente de 10 secondes avant de changer l'activit√© et le statut
    for guild in bot.guilds:
        GUILD_SETTINGS[guild.id] = load_guild_settings(guild.id)

# Gestion des erreurs globales pour toutes les commandes
@bot.event
async def on_error(event, *args, **kwargs):
    print(f"Une erreur s'est produite : {event}")
    embed = discord.Embed(
        title="‚ùó Erreur inattendue",
        description="Une erreur s'est produite lors de l'ex√©cution de la commande. Veuillez r√©essayer plus tard.",
        color=discord.Color.red()
    )
    await args[0].response.send_message(embed=embed)

@bot.hybrid_command(
    name="uptime",
    description="Affiche l'uptime du bot."
)
async def uptime(ctx):
    uptime_seconds = round(time.time() - start_time)
    days = uptime_seconds // (24 * 3600)
    hours = (uptime_seconds % (24 * 3600)) // 3600
    minutes = (uptime_seconds % 3600) // 60
    seconds = uptime_seconds % 60
    embed = discord.Embed(
        title="Uptime du bot",
        description=f"Le bot est en ligne depuis : {days} jours, {hours} heures, {minutes} minutes, {seconds} secondes",
        color=discord.Color.blue()
    )
    embed.set_footer(text=f"‚ô•Ô∏èby Iseyg", icon_url=ctx.author.avatar.url)
    await ctx.send(embed=embed)


@bot.hybrid_command(name="bal", aliases=["balance", "money"], description="Affiche ta balance ou celle d'un autre utilisateur.")
async def bal(ctx: commands.Context, user: discord.User = None):
    user = user or ctx.author
    guild_id = ctx.guild.id
    user_id = user.id

    # Cherche les donn√©es de l'utilisateur dans la collection ether_eco
    data = collection.find_one({"guild_id": guild_id, "user_id": user_id})

    balance = data.get("wallet", 0) if data else 0
    bank = data.get("bank", 0) if data else 0
    total = balance + bank

    embed = discord.Embed(title=f"üí∞ Balance de {user.display_name}", color=discord.Color.gold())
    embed.add_field(name="Portefeuille", value=f"{balance} ü™ô", inline=True)
    embed.add_field(name="Banque", value=f"{bank} üè¶", inline=True)
    embed.add_field(name="Total", value=f"{total} üíµ", inline=False)
    embed.set_footer(text=f"Demand√© par {ctx.author}", icon_url=ctx.author.display_avatar.url)

    await ctx.send(embed=embed)

@bot.hybrid_command(name="deposit", aliases=["dep"], description="D√©pose de l'argent de ton portefeuille vers ta banque.")
@app_commands.describe(amount="Montant √† d√©poser (ou 'all')")
async def deposit(ctx: commands.Context, amount: str = None):
    if amount is None:
        return await ctx.send("‚ùå Tu dois sp√©cifier un montant ou `all`.")

    user = ctx.author
    guild_id = ctx.guild.id
    user_id = user.id

    # Chercher les donn√©es actuelles
    data = collection.find_one({"guild_id": guild_id, "user_id": user_id}) or {"wallet": 0, "bank": 0}

    wallet = data.get("wallet", 0)
    bank = data.get("bank", 0)

    # G√©rer le cas "all"
    if amount.lower() == "all":
        if wallet == 0:
            return await ctx.send(f"üí∏ Tu n'as rien √† d√©poser.")
        deposited_amount = wallet
    else:
        # V√©rifie que c'est un nombre valide
        if not amount.isdigit():
            return await ctx.send("‚ùå Montant invalide. Utilise un nombre ou `all`.")
        deposited_amount = int(amount)
        if deposited_amount <= 0:
            return await ctx.send("‚ùå Tu dois d√©poser un montant sup√©rieur √† z√©ro.")
        if deposited_amount > wallet:
            return await ctx.send("‚ùå Tu n'as pas assez d'argent dans ton portefeuille.")

    # Mise √† jour dans la base de donn√©es
    collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        {"$inc": {"wallet": -deposited_amount, "bank": deposited_amount}},
        upsert=True
    )

    await ctx.send(f"‚úÖ Tu as d√©pos√© **{deposited_amount} ü™ô** dans ta banque.")

@bot.hybrid_command(name="withdraw", aliases=["with"], description="Retire de l'argent de ta banque vers ton portefeuille.")
async def withdraw(ctx: commands.Context, amount: str):
    user = ctx.author
    guild_id = ctx.guild.id
    user_id = user.id

    # Chercher les donn√©es actuelles
    data = collection.find_one({"guild_id": guild_id, "user_id": user_id}) or {"wallet": 0, "bank": 0}

    wallet = data.get("wallet", 0)
    bank = data.get("bank", 0)

    # G√©rer le cas "all"
    if amount.lower() == "all":
        if bank == 0:
            return await ctx.send(f"üí∏ Tu n'as rien √† retirer.")
        withdrawn_amount = bank
    else:
        # V√©rifie que c'est un nombre valide
        if not amount.isdigit():
            return await ctx.send("‚ùå Montant invalide. Utilise un nombre ou `all`.")
        withdrawn_amount = int(amount)
        if withdrawn_amount <= 0:
            return await ctx.send("‚ùå Tu dois retirer un montant sup√©rieur √† z√©ro.")
        if withdrawn_amount > bank:
            return await ctx.send("‚ùå Tu n'as pas assez d'argent dans ta banque.")

    # Mise √† jour dans la base de donn√©es
    collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        {"$inc": {"wallet": withdrawn_amount, "bank": -withdrawn_amount}},
        upsert=True
    )

    await ctx.send(f"‚úÖ Tu as retir√© **{withdrawn_amount} ü™ô** de ta banque vers ton portefeuille.")

@bot.hybrid_command(name="add-money", description="Ajoute de l'argent √† un utilisateur (r√©serv√© aux administrateurs).")
@app_commands.describe(
    user="L'utilisateur √† cr√©diter",
    amount="Le montant √† ajouter",
    account="Choisis o√π ajouter l'argent : bank ou wallet"
)
@commands.has_permissions(administrator=True)
async def add_money(ctx: commands.Context, user: discord.User, amount: int, account: str):
    if account.lower() not in ["wallet", "bank"]:
        return await ctx.send("‚ùå Veuillez choisir `wallet` ou `bank` comme compte cible.")

    if amount <= 0:
        return await ctx.send("‚ùå Le montant doit √™tre sup√©rieur √† z√©ro.")

    guild_id = ctx.guild.id
    user_id = user.id

    # Mise √† jour MongoDB
    collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        {"$inc": {account.lower(): amount}},
        upsert=True
    )

    await ctx.send(f"‚úÖ Tu as ajout√© **{amount} ü™ô** √† {user.mention} dans son **{account.lower()}**.")

# Gestion des erreurs de permissions
@add_money.error
async def add_money_error(ctx, error):
    if isinstance(error, commands.MissingPermissions):
        await ctx.send("üö´ Tu n'as pas la permission d'utiliser cette commande.")

@bot.hybrid_command(name="remove-money", description="Retire de l'argent √† un utilisateur.")
@app_commands.describe(user="L'utilisateur cibl√©", amount="Le montant √† retirer", location="Choisis entre wallet ou bank")
@app_commands.choices(location=[
    app_commands.Choice(name="Wallet", value="wallet"),
    app_commands.Choice(name="Bank", value="bank"),
])
@commands.has_permissions(administrator=True)
async def remove_money(ctx: commands.Context, user: discord.User, amount: int, location: app_commands.Choice[str]):
    if amount <= 0:
        return await ctx.send("‚ùå Le montant doit √™tre sup√©rieur √† 0.")

    guild_id = ctx.guild.id
    user_id = user.id

    field = location.value

    # V√©rifie le solde actuel
    data = collection.find_one({"guild_id": guild_id, "user_id": user_id}) or {"wallet": 0, "bank": 0}
    current_balance = data.get(field, 0)

    if current_balance < amount:
        return await ctx.send(f"‚ùå {user.display_name} n'a pas assez de fonds dans son `{field}` pour retirer {amount} ü™ô.")

    # Met √† jour la base de donn√©es
    collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        {"$inc": {field: -amount}},
        upsert=True
    )

    await ctx.send(f"‚úÖ Tu as retir√© **{amount} ü™ô** de la **{field}** de {user.mention}.")

@remove_money.error
async def remove_money_error(ctx, error):
    if isinstance(error, commands.MissingPermissions):
        await ctx.send("‚ùå Tu dois √™tre administrateur pour utiliser cette commande.")
    else:
        await ctx.send("‚ùå Une erreur est survenue.")


# Token pour d√©marrer le bot (√† partir des secrets)
# Lancer le bot avec ton token depuis l'environnement  
keep_alive()
bot.run(token)
